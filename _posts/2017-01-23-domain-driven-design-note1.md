---
layout: post
title: 《领域驱动设计》笔记1
categories: coding
---

《领域驱动设计——软件核心复杂度应对之道》这本书很早就像看了，但是一直找不到正版，去年人邮异步社区再版，买了本纸质版，最近终于有时间开始看了。看了几章，回顾自己的项目经历，发现比较成功的项目都不自觉的遵循了书中的一些原则，而失败的项目则印证了书中反对的做法，虽然我想说早看几年就好了，但是可能早看几年没有现在这么深的切身体会吧。

## 序

Martin Fowler大神写的序言，他说作者比他技艺精湛。为什么序言我也做一下笔记，因为我觉得他把本书的要义概况出来了。

软件的复杂性的根本原因是问题领域的复杂性，这些复杂性是无法回避的，只能进行控制，而好的领域模型就是控制复杂性的最佳方法。

建模这种事情，很多书都会谈，在我的项目经历中，也被迫按所谓的软件工程化要求写了很多文档，但是文档起到的效果很有限。两点原因：

1. 在领域建模过程中不应将概念与实现分割开来；
2. 领域模型不是按照“先建模，后实现”这个次序来工作的。

## 前言

### 三个项目的对比

1. 未使用领域语言，缺乏扩展性，成为遗留系统；
2. 使用了领域驱动设计，获得了成功；
3. 使用了领域语言，但是设计与实现脱节，项目部分目标失败。

### 复杂性的挑战

复杂性失控是软件失败的主要原因，很多应用程序最主要的复杂性并不在技术上，而是来自领域本身、用户的活动或业务。

本书的两个前提：

1. 在大多数软件项目中，主要的焦点应该是领域和领域逻辑；(*程序员容易模糊焦点，太关注具体的技术*)
2. 复杂的领域涉及应该基于模型。

### 设计过程与开发过程

本书假定项目必须遵循两个开发实践

1. 迭代开发。
2. 开发人员与领域专家具有密切的关系。

### 本书的结构

1. 运用领域模型：方法论的一些基本概念；
2. 模型驱动设计的构造块：面向对象中一些支持领域驱动设计的最佳实践（模式）；
3. 通过重构来加深理解：如果迭代出一个好的模型；
4. 战略设计：大型系统的设计。

### 本书面向的读者

1. 中级软件开发人员
2. 高级软件开发人员
3. 技术经理
4. 分析员

## 第一部分 运用领域模型

领域模型是对领域知识严格的组织且有选择的抽象。

模型在领域驱动设计中的作用：

1. 模型和设计的核心相互影响；
2. 模型是团队所有成员使用的通用语言的中枢；
3. 模型是浓缩的知识。

软件的核心是什么？是其为用户解决领域相关问题的能力，不要总是试图用技术解决领域问题。

### 第一章 消化知识

### 1.1 有效建模的要素

1. 模型和实现的绑定；
2. 建立了一种基于模型的语言；
3. 开发了一个蕴含丰富知识的模型；
4. 提炼模型；
5. 头脑风暴和实验。

### 1.2 知识消化

高效的领域建模人员是知识的消化者。

知识消化活动的人员：开发人员（领导者）、领域专家。

知识的来源：领域专家头脑中的知识、现有系统的用户、技术团队经验。

信息的形式：项目文档、业务文件、讨论、早期版本与原型软件。

瀑布方法的问题：知识只能单向流动，领域专家与分析员得不到程序员的反馈；

一般迭代过程的问题：未建立知识体系，没有扩展性。

领域驱动设计要达到的效果：知识的双向流动，模型的精化推动开发人员和领域专家不断相互学习。

###  1.3 持续学习

知识最初是零散的，没有人最开始就知道好的模型是什么样的。

项目会丢失知识。

只有持续学习，持续迭代才能出现好的模型，持续学习者将成为团队的中坚。

### 1.4 知识丰富的模型

一些隐含的概念应当通过讨论，将它们变成显式的概念（类），这样这些概念到了重视与排查，程序也具备了扩展的可能性。

### 1.5 深度模型

最初提出的模型可能会进行比较大的更改，有一些概念会删除，也有一些概念会增加。

## 第2章 交流与语言的使用

### 2.1 模式：UBIQUITOUS LANGUAGE

领域专家和技术团队使用统一语言。

文档、代码、沟通使用统一语言。

模型与语言相互塑造。（*语言反塑造思想，这是很有趣的事情*）

对语言的更改就是对模型的更改。

（*代码大全中花了一章讲命名，这本书也差不多，老子说的，有名，万物之始。*）

### 2.2 “大声地”建模

这一节强调了口头语言与模型的相互作用。（*个人体会，很多问题只要说出来，还没讨论就清晰了很多。*）

在口头表达中坚持使用模型语言。

### 2.3 一个团队，一种语言

如果连经验丰富的领域专家都不能理解模型，那么模型一定出了什么问题。

这种语言是开发人员与领域专家术语的交集，应当在迭代精化过程中不断消除理解上的分歧。它主要包括的因素：

1. 领域模型术语；
2. BOUNDED CONTEXS的名称；
3. 大型结构的术语；
4. 本书中提到的很多模式名称。

（*第一种因项目而异，后面三种可以通过本书好好学一下*）

### 2.4 文档和图

UML图：类图、对象交互图。

通过简单、非正式的UML图维系讨论。

不要画得过细，导致只见树木，不见森林。

设计得重要细节应该在代码中体现出来。

模型不是图。

#### 2.4.1 书面设计文档

1. 文档应作为代码和口头交流的补充：文档不应再重复表示代码已经明确表达出的内容。
2. 文档应当鲜活并保持最新：文档必须深入到各种项目活动中去。

#### 2.4.2 完全依赖可执行代码的情况

代码不一定正确的表达了设计意图。

使用声明式编程。

### 2.5 解释性模型

解释性模型能够帮助学习，建议最好不用对象模型，以免混淆到设计中去。

## 第3章 绑定模型和实现

### 3.1 模式：MODEL-DRIVEN-DESIGN

如果整个程序设计或者其核心部分没有雨领域模型相应，那么整个模型就是没有价值的，软件的正确性也值得怀疑。同时，模型和设计功能之间过于复杂的对应关系也是难于理解的，在实际项目中，当设计改变时也无法维护这种关系。若分析和设计之间产生严重分歧，那么在分析和设计活动中所获得的知识就无法彼此共享。

因此：软件系统各个部分的设计应该忠实反映领域模型，以便体现出这二者之间的明确对应关系，我们应该反复检查并修改模型，以便软件可以更加自然的实现模型，即使想让模型反映出更深层次的领域概念时也应如此。我们需要的模型不但应该满足这两种需求，还应该能够支持健壮的UBIQUITOUS LANGUAGE。

从模型中获取用于程序设计和基本职责分配的术语。让程序代码成为模型的表达，代码的改变可能会是模型的改变。而其影响势必要波及接下来的项目活动。

完全依赖模型的实现通常需要支持建模范式的软件开发工具和语言，比如面向对象的编程。

### 3.2 建模范式和工具支持

面向对象设计时目前大多数项目所使用的建模范式，也是本书中使用的主要方法。

面向过程语言不适合建模。Prolog语言适合建模。

（*实际上没有银弹，所以很多语言多发展到多范式了，比如Java8的lamda表达式*）

### 3.3 揭示主旨：为什么模型对用户至关重要

如果程序设计基于一个能反映出用户和领域专家所关心的问题的模型，那么与其他设计方式相比，这种设计可以将主旨更明确的展示给用户。让用户了解模型，将使他们有更多机会挖掘软件的潜能，也能使软件的行为合乎情理、前后一致。

### 3.4 模式：HANDS-ON MODELER

任何参与建模的技术人员，不管在项目中的主要职责是什么，都必须花时间了解代码。任何负责修改代码的人员必须学会用代码来表达模型。每一个开发人员都必须不同程度地参与模型讨论并且与领域专家保持联系。参与不同工作的人都必须有意识的通过UBIQUITOUS LANGUAGE与接触代码的人及时交换关于模型的想法。

（*现实情况时，讨论了半天，没有一个概念，程序员随手写了很多莫名其妙的类，通过巧合，最后软件实现了用户要求的（部分）功能。*）