---
5layout: post
title: 《构建之法》01~03
categories: coding
---

### 第2章 个人技术和流程

这本书比较有意思的一点就是它的软件工程是从个人开发讲起的，实际上这对一个学生来说，是最有直观感受的。毕竟，再怎么样，程序至少也是一个人写出来的，即使只是自己管自己，也需要一些工程最佳实践。这一章主要讲了两个，都是结合Virtual Studio来讲的，我算是相当熟悉了。

1. 单元测试：我写C#代码的时候，还是写过不少单元测试的，但是并不能很好的坚持下来，我仔细想想，往往是因为做的项目都是上峰的意志，急着看到效果第一，所以质量上是放水状态的，工期一赶就把测试都放到最后一起做了，这是这几年工作最大的遗憾之一了吧。单元测试其实不单单能测出一些问题，更重要的是可以因为单元测试而变换思考的角度，从使用函数和类的角度来设计往往更合理，为了完成测试，模块的划分也会更合理。
2. 效能分析工具：一般科班出身的程序员对性能的了解是很学术的，比如复杂度分析之类的，至少知道O(n),O(lgn)之类的。有些习惯了写C语言刷算法题的，甚至在写业务逻辑时，也爱去想怎样写可能效率高一点，这往往是一个陷阱。我有个师弟去年写一个机器学习算法的时候，发现效率不高，于是冥思苦想要怎么优化，我建议他用VS的工具分析一下，找到调用次数最多的函数后，发现瓶颈完全不在自己以为的地方，算法的核心部分效率很好，反而是预处理时数据复制的方式不好，导致效能低下。过早优化是一种罪恶，大致如此。

好的单元测试的标准：

* 应该在最基本的功能/参数上验证程序的正确性
* 必须由最熟悉代码的人（程序的作者）来写
* 单元测试过后，机器状态保持不变
* 要快
* 应该产生可重复、一致的结果
* 独立性
* 应该覆盖所有代码路径
* 应该集成到自动测试的框架中
* 必须和产品代码一起保存和维护

回归测试的目的：

1. 验证新的代码的确改正了缺陷
2. 同时要验证新的代码没有破坏模块的现有功能，有没有回归

效能测试的主要分析方法包括抽样和代码注入。

个人开发流程PSP，需要记录各项任务的时间

Planning

* Estimate

Development

* Analysis
* Design Spec
* Design Review
* Coding Standard
* Design
* Coding
* Code Review
* Test

Record Time Spent

Test Report

Size Measurement

Postmortem

Process Improvement Plan

一般来说，工程师相比学生花了更多的时间进行需求分析和测试，而花了较少的时间编码。

### 第3章 软件工程师的成长

如何衡量软件开发的工作量和质量：

1. 代码行数
2. 人月
3. 每千行错误个数，返工次数
4. 是否按时交付，交付时间的方差

团队对个人的期望：

1. 交流
2. 说到做到
3. 接受团队赋予的角色并按角色要求工作
4. 全力投入团队的活动
5. 按照团队流程的要求工作
6. 准备
7. 理性地工作

软件工程师地思维误区:

1. 分析麻痹
2. 不分主次，想解决所有依赖问题
3. 过早优化
4. 过早扩大化/泛化：xx平台
5. 画扇面——调侃目标和远景：画大饼画得太大

职业成长路线

Steve McConnell：入门、熟练、带头人、大师

微软：初级、中级、高级、首席

[自我评价清单](http://www.cnblogs.com/xinz/p/3852177.html), 我大致看了一下，自我评价算是处在中游水平，对于代码还是有自我追求的，只是也干了很多应付交差的的事情。

技能的反面是解决问题：如果把时间花在解决低层次问题上，就无暇顾及其他了。

我发现写软件的技能和开车也是可以类比的，在原书的基础上加上了最后一列

| 层次     | 状态     | 教育理论   | 类比开车                 |
| ------ | ------ | ------ | -------------------- |
| 高层次问题  | 无暇顾及   | 恐慌区    | 赛车技巧                 |
| 中间层次问题 | 花脑力解决  | 学习区    | 观察路面的各种情况            |
| 低层次问题  | 变成自动操作 | 舒适区，精通 | 如何换挡，如何踩离合，如何刹车需要自动化 |

