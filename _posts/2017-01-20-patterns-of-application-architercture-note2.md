---
layout: post
title:  《企业应用架构模式》笔记1
categories: coding
---
## 第5章 并发

使用事务管理程序(数据库事务)避开并发问题。

仍然存在的并发问题：

1. 离线并发：跨事务的数据处理中管理并发问题；
2. 服务器系统中的多线程应用

### 5.1 并发问题

并发问题的本质

1. 更新丢失：对同一份数据的不同更新，后获取的先更新完；
2. 不一致读：相互关联的几个数据因为更新处在不一致状态，而且被其他用户读到。

### 5.2 执行语境

请求：软件工作的外部环境发出的单个调用；

会话：客户端和服务器端之间一次长时间的交互，通常由一系列请求构成。

进程与线程

事务

### 5.3 隔离与不变性

解决并发问题的基本方案：

1. 隔离：同一份数据只允许一个执行单元同时访问，其他执行单元最多打开只读副本。
2. 不变性：识别哪些是不变的数据，允许共享它们。

### 5.4 乐观并发控制和悲观并发控制

乐观锁：可随意获取，提交时进行冲突检测；

悲观锁：访问前先获得锁，加锁后其他执行单元不可获取该资源。

#### 5.4.1 避免不一致读

悲观锁：读加锁与写加锁；

乐观锁：将冲突检测建立在数据的某种版本标记上，可能是时间戳或者顺序计数器。

#### 5.4.2 死锁

悲观锁的问题。

1. 死锁检测或超时检测：需要牺牲者；
2. 预防机制：一次性获取所有锁。

### 5.5 事务

#### 5.5.1 ACID

原子性、隔离性、一致性、持久性

#### 5.5.2 事务资源

最常见的事务资源是数据库。

1. 尽量使用短事务，而不使用跨越多个请求的长事务；
2. 请求事务是一个简单实用的模型；
3. 尽可能晚打开事务，使用延迟事务；
4. 避免锁升级；

#### 5.5.3 减少事务隔离以提高灵活性

| 隔离级别 | 脏读   | 不可重复读 | 幻读   |
| ---- | ---- | ----- | ---- |
| 读未提交 | √    | √     | √    |
| 读已提交 |      | √     | √    |
| 可重复读 |      |       | √    |
| 可串行化 |      |       |      |

隔离度越高，灵活性越差。

#### 5.5.4 业务事务和系统事务

1. 尽量直接使用系统事务，避免需要分解的长事务；
2. 无法避免时，需要自己支持ACID，通过提交容易支持原子性和持久性，使用工作单元模式跟踪修改。隔离性支持比较复杂，没有隔离性就没有一致性。
3. 假设所有业务事务都是在单个客户会话中执行。

### 5.6 离线并发控制的模式

乐观离线锁：首选，易于实现，局限是提交时才能发现错误。

悲观离线锁：难实现，能尽早发现错误。

粗粒度锁与隐含锁。

### 5.7 应用服务器并发

每会话一进程：实现简单，隔离好，资源消耗太大。

每会话一线程：容易把进程整个整崩溃，实现复杂，但是省资源。需要创建和进入一个隔离区。

为每个会话创建新的对象能避免很多并发问题，注意对静态的基于类的变量或全局变量（包括单例）要同步，必要时使用缓冲池（如数据库连接池）。

## 第6章 会话状态

### 6.1 无状态的价值

1. 注意区分这里不是指无状态的对象
2. 无状态使得一个服务器对象可以服务多个用户，提高系统性能，因为用户大部分时间可能是没有操作的。
3. 但是很多会话从本质上看是有状态的，这需要用无状态服务器去实现。

### 6.2 会话状态

1. 会话状态存在与事务中，但不一定满足事务的特性，可能要到提交的时候才能发现不一致性；
2. 注意区分会话中的数据与会话状态，通过会话状态可以重建会话中的数据。

### 6.3 存储会话状态的方法

1. 客户会话状态：使用Cookie或隐藏域，或胖客户端的对象结构
2. 服务器会话状态：内存，或序列化到文件、数据库
3. 数据库会话状态：使用数据库表存储

注意：

1. 带宽问题，客户会话状态占用带宽大
2. 使用客户会话状态需要对数据加密
3. 数据隔离，使用数据库会话状态比较难
4. 会话迁移和服务器亲和力：服务器会话状态难迁移，注意集群系统中会话的识别问题，考虑代理引起的IP重复。
5. 会话状态转换成便于快速访问的形式
6. 会话的关闭：服务器超时机制，客户端主动关闭。
7. 几种方法可以综合使用，建议优先服务器会话状态，客户会话状态保存少量数据。

## 第7章 分布策略

### 7.1 分布对象的诱惑

1. 分布对象并不能带来性能的提升
2. 性能数量级差异：进程内调用>本机进程间调用 >跨机器进程间调用

### 7.2 远程接口和本地接口

1. 根本性差异：本地接口是细粒度的，但为了性能，远程接口应当是粗粒度的；
2. 分布对象设计第一定律：不用分布使用对象；
3. 如何有效利用多处理器资源：使用集群系统，复制对象，进程内调用。

### 7.3 必须使用分布的情况

1.  客户机和服务器之间
2.  基于服务器的应用软件和数据库之间
3.  Web服务器和应用服务器之间
4.  不同厂商应用之间
5.  其他原因

### 7.4 关于分布边界

1. 尽可能限制分布边界
2. 进程内使用细粒度设计，通过远程外观提供粗粒度访问接口；
3. 数据传输对象一般只引用其他数据传输对象和原始对象；
4. 通过代理在进程间迁移对象。

### 7.5 分布接口

3种形式：

1. 基于RPC的接口：效率高，同质应用应当优先考虑
2. 基于xml的接口：跨平台交互；
3. HTTP接口加面向对象接口混用

同步的基于RPC的接口，或者异步的，基于消息的接口。

## 第8章 通盘考虑

1. 书中的建议推动思考，而不能代替思考；
2. 架构重构的相关技术：持续集成，测试驱动的开发，重构

### 8.1 从领域层开始

1. 事务脚本模式：过程模型，问题很简单时适用；
2. 领域模型模式：面向对象设计优先使用；
3. 表模块模式：工具环境支持好使用。

### 8.2 深入到数据源层

1. 事务脚本的数据源：行数据入口、表数据入口（记录集支持良好时优先使用）。
2. 表模块的数据源：记录集与表数据入口，内置并发控制时成为工作单元模式。
3. 领域模型的数据源：简单一点使用活动记录，表数据入口或行数据入口，复杂起来后使用数据映射器与工作单元。

### 8.3 表现层

1. 优先考虑Web而不是胖客户端；
2. 以MVC模式为基础
3. 可根据开发工具选择方案：视图控制器+模板视图，前端控制器+模板视图
4. 模板视图（略占上风），转换视图
5. 两步视图（*现在有响应式前端设计*）

### 8.4 一些关于具体技术的建议

2002年

#### 8.4.1 Java和J2EE

EJB技术，POJO（*现在这些技术都不流行了，现在广泛使用的主要是Spring？*）

### 8.4.2 .Net

1. 表模块的良好支持
2. Web Service支持

(*.Net中技术迭代了几轮，现在主推的是.Net Core MVC*)

### 8.3.3 存储过程

1. 性能优化手段，而不是架构原则
2. 像其他SQL访问一样需要隔离

#### 8.3.4 Web Service 

谨防Web Service万能论调

### 8.5 其他分层方式

基本上可以对应到三层架构，部分将三层架构中的某一层再细分，略。